Section 1 (Frederik)
Introduction.
This program simulates an auction between 3 clients calling a server, which after an update to the bidding backs itself up to a backup server.
The Auction ends after the servers logical clock, implemented using Lamport clock, hits 100-
During runtime there is a not zero chance that the main server "crashes" and the clients switches to use the backup server.
The endpoints for the servers are hardcoded into the clients.
All nodes the program needs to have to run smoothly are made when running the run_all scrip, and the logs a specific node can be found in the logs folder

Section 2 (Frederik)
Architecture.
For the auction to work GRPC is used. Here there are 4 different message types and 3 rpc services.
The message types are: Bid, contains author, timestamp and bid, Result, contains status, bid and timestamp, Ack, which is empty and Empty, which is also empty.
The rpc services are: Bidding, takes Bid returns Ack, Query, takes Empty returns Result and CallBackup takes Result returns Ack.
The Bidding and Query services are used by the clients to call the server. These do so you can bid in the auction and find out if it is still ongoing and what the highest bid is at.
The CallBackup is used between the servers, where the main server calls the backup server to update how the auction is going. This is where the programs replication happens

Section 3 (Hassan)
Correctness 1. Argue whether your implementation satisfies
linearisability or sequential consistency. In order to do so, first,
you must state precisely what such property is.
To be sequentially consistent it would mean that for any execution issued by the clients, there exists precisely a singluar correct interleaving of operation issued by the clients, and that the interleaving is consistent with the order of which they were issued by the individual clients. 
This is where linearisability would instead require the interleaving to be consistent with the real time ordering of the operations instead of the order of which they were issued by the individual clients. Hence linearisability implies sequential consistency but NOT vice versa.
This program is sequentially consistent but not linearisable. The server determines the interleaving of operations issued by the clients using lamport clock, and grpc makes sure interleaving is consistent with the order of which they were issued by the individual clients. 

Section 4 (Nikolej)
Correctness 2. An argument that your protocol is correct in the absence and the presence of failures.

Let's discuss correctness under primary failure, as the program is designed to demonstrate exactly one failure.
Trivially, the primary server is replaced by a unique backup, since there is only one backup.
The primary server is its own replication manager, since it replicates itself using an grpc service. Since we only have the one replication manager, it always agrees which operations have been performed at the time of the backup taking over. The backup server in turn becomes its own replica manager.
Since the program has 2 replica managers, (servers serving as their own replica managers) the program can handle exactly one crash.

Now let's discuss correctness in the absense of failures.
Assuming that the program is not scripted to crash the primary server, it would continue to run as long as the primary server is online. This is because, as mentioned, it serves as its own crash replica manager, being responsible for backing up every time it receives a bid.
